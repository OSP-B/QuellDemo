"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const visitor_1 = require("graphql/language/visitor");
/**
 * Traverses the abstract syntax tree depth-first to determine which operations types are
 * 'unQuellable' along the AST.
 * @param {Object} AST - Abstract syntax tree generated by GraphQL library.
 * @returns {Object} Object containing operation type is 'unQuellable' and prototype object.
 */
function determineType(AST) {
    // Initialize prototype as empty object
    // Information from the AST is distilled into the prototype for easy
    // access during caching, rebuilding query strings, etc.
    const proto = {};
    // The frags object will contain the fragments defined in the query in a format
    // similar to the proto.
    const frags = {};
    // Create an args object that will be populated with the node's arguments.
    const argsObj = {};
    // Create variable target object that will be updated to point to prototype when iterating
    // through Field nodes and to point to frags when iterating through Fragment Definition nodes.
    let targetObj;
    // Create operation type variable. This will be 'query', 'mutation', 'subscription', 'noID', or 'unQuellable'.
    let operationType = '';
    // Initialize a stack to keep track of depth first parsing path.
    const stack = [];
    // Tracks depth of selection Set
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    let selectionSetDepth = 0;
    // Create field arguments object, which will track the id, type, alias, and args for the fields.
    // The field arguments object will eventually be merged with the prototype object.
    const fieldArgs = {};
    /**
     * visit is a utility provided in the graphql-JS library. It performs a
     * depth-first traversal of the abstract syntax tree, invoking a callback
     * when each SelectionSet node is entered. That function builds the prototype.
     * Invokes a callback when entering and leaving Field node to keep track of nodes with stack
     *
     * Find documentation at:
     * https://graphql.org/graphql-js/language/#visit
     */
    (0, visitor_1.visit)(AST, {
        // The enter function will be triggered upon entering each node in the traversal.
        enter(node) {
            var _a, _b;
            // Quell cannot cache directives, so we need to return as unQuellable if the node has directives.
            if (node === null || node === void 0 ? void 0 : node.directives) {
                if ((_b = (_a = node === null || node === void 0 ? void 0 : node.directives) === null || _a === void 0 ? void 0 : _a.length) !== null && _b !== void 0 ? _b : 0 > 0) {
                    operationType = 'unQuellable';
                    // Return BREAK to break out of the current traversal branch.
                    return visitor_1.BREAK;
                }
            }
        },
        // If the current node is of type OperationDefinition, this function will be triggered upon entering it.
        // It checks the type of operation being performed.
        OperationDefinition(node) {
            targetObj = proto;
            // Quell cannot cache subscriptions, so we need to return as unQuellable if the type is subscription.
            operationType = node.operation;
            if (operationType === 'subscription') {
                operationType = 'unQuellable';
                // Return BREAK to break out of the current traversal branch.
                return visitor_1.BREAK;
            }
        },
        // If the current node is of type FragmentDefinition, this function will be triggered upon entering it.
        FragmentDefinition: {
            enter(node) {
                // Get the name of the fragment.
                const fragName = node.name.value;
                // Add the fragment name to the stack.
                stack.push(fragName);
                // Add the fragment name as a key in the target object (which will be frags while inside the
                // loop below), initialized to an empty object.
                targetObj = frags;
                targetObj[fragName] = {};
                // Loop through the selections in the selection set for the current FragmentDefinition node
                // in order to extract the fields in the fragment.
                for (let i = 0; i < node.selectionSet.selections.length; i++) {
                    // Below, we get the 'name' property from the SelectionNode.
                    // However, InlineFragmentNode (one of the possible types for SelectionNode) does
                    // not have a 'name' property, so we will want to skip nodes with that type.
                    if (node.selectionSet.selections[i].kind !== 'InlineFragment') {
                        // Add base-level field names in the fragment to the frags (aka target) object.
                        targetObj[fragName][node.selectionSet.selections[i].name.value] = true;
                    }
                }
            },
            // If the current node is of type FragmentDefinition, this function will be triggered after visiting it and all of its children.
            leave() {
                // Pop stacks to keep track of depth-first parsing path.
                stack.pop();
            }
        },
        Field: {
            // If the current node is of type Field, this function will be triggered upon entering it.
            enter(node) {
                // Return introspection queries as unQuellable so that we do not cache them.
                // "__keyname" syntax is later used for Quell's field-specific options, though this does not create collision with introspection.
                if (node.name.value.includes('__')) {
                    operationType = 'unQuellable';
                    // Return BREAK to break out of the current traversal branch.
                    return visitor_1.BREAK;
                }
                // Loop through the field's arguments.
                if (node.arguments) {
                    node.arguments.forEach((arg) => {
                        const key = arg.name.value;
                        // Quell cannot cache queries with variables, so we need to return unQuellable if the query has variables.
                        if (arg.value.kind === 'Variable' && operationType === 'query') {
                            operationType = 'unQuellable';
                            // Return BREAK to break out of the current traversal branch.
                            return visitor_1.BREAK;
                        }
                        /*
                         * In the next step, we get the value from the argument node's value node.
                         * This assumes that the value node has a 'value' property.
                         * If the 'kind' of the value node is ObjectValue, ListValue, NullValue, or ListValue
                         * then the value node will not have a 'value' property, so we must first check that
                         * the 'kind' does not match any of those types.
                         */
                        if (arg.value.kind === 'NullValue' ||
                            arg.value.kind === 'ObjectValue' ||
                            arg.value.kind === 'ListValue') {
                            operationType = 'unQuellable';
                            // Return BREAK to break out of the current traversal branch.
                            return visitor_1.BREAK;
                        }
                        // Assign argument values to argsObj (key will be argument name, value will be argument value),
                        // skipping field-specific options ('__') provided as arguments.
                        if (!key.includes('__')) {
                            argsObj[key] = arg.value.value;
                        }
                    });
                }
                // Set the fieldType equal to either the field's alias or the field's name.
                const fieldType = node.alias
                    ? node.alias.value
                    : node.name.value;
                // Add the field type to stacks to keep track of depth-first parsing path.
                stack.push(fieldType);
            },
            // If the current node is of type Field, this function will be triggered after visiting it and all of its children.
            leave() {
                // Pop stacks to keep track of depth-first parsing path.
                stack.pop();
            }
        },
        SelectionSet: {
            // If the current node is of type SelectionSet, this function will be triggered upon entering it.
            // The selection sets contain all of the sub-fields.
            // Iterate through the sub-fields to construct fieldsObject
            enter(node, key, parent, 
            // eslint-disable-next-line @typescript-eslint/no-unused-vars
            path, 
            // eslint-disable-next-line @typescript-eslint/no-unused-vars
            ancestors) {
                selectionSetDepth++;
                /*
                 * Exclude SelectionSet nodes whose parents are not of the kind
                 * 'Field' to exclude nodes that do not contain information about
                 *  queried fields.
                 */
                if (parent && // parent is not undefined
                    !Array.isArray(parent) && // parent is not readonly ASTNode[]
                    parent.kind === 'Field' // can now safely assume that parent will have 'kind' property
                ) {
                    // Create fieldsValues object that will be used to collect fields as
                    // we loop through the selections.
                    const fieldsValues = {};
                    for (const field of node.selections) {
                        /*
                         * If the current selection in the selections array is not a nested object
                         * (i.e. does not have a SelectionSet), set its value in fieldsValues to true.
                         * Below, we get the 'name' property from the SelectionNode.
                         * However, InlineFragmentNode (one of the possible types for SelectionNode) does
                         * not have a 'name' property, so we will want to skip nodes with that type.
                         * Furthermore, FragmentSpreadNodes never have a selection set property.
                         */
                        if (field.kind !== 'InlineFragment' &&
                            (field.kind === 'FragmentSpread' || !field.selectionSet))
                            fieldsValues[field.name.value] = true;
                    }
                    // If ID was not included on the request and the current node is not a fragment, then the query
                    // will not be included in the cache, but the request will be processed.
                    if (!Object.prototype.hasOwnProperty.call(fieldsValues, 'id') &&
                        !Object.prototype.hasOwnProperty.call(fieldsValues, '_id') &&
                        !Object.prototype.hasOwnProperty.call(fieldsValues, 'ID') &&
                        !Object.prototype.hasOwnProperty.call(fieldsValues, 'Id')) {
                        operationType = 'unQuellable';
                        // Return BREAK to break out of the current traversal branch.
                        return visitor_1.BREAK;
                    }
                    // Place current fieldArgs object onto fieldsObject so it gets passed along to prototype.
                    // The fieldArgs contains arguments, aliases, etc.
                    const fieldsObject = Object.assign(Object.assign({}, fieldsValues), fieldArgs[stack[stack.length - 1]]);
                    // Loop through stack to get correct path in proto for temp object;
                    // mutates original prototype object WITH values from tempObject
                    // "prev" is accumulator ie the prototype
                    stack.reduce((prev, curr, index) => {
                        // if last item in path, set value
                        if (index + 1 === stack.length)
                            prev[curr] = Object.assign({}, fieldsObject);
                        return prev[curr];
                    }, targetObj);
                }
            },
            leave() {
                // Tracking depth of selection set
                selectionSetDepth--;
            }
        }
    });
    return { operationType, proto };
}
exports.default = determineType;
